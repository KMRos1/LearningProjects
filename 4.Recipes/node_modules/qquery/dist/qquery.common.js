'use strict';

/**
 * Checks if the value has a certain type-string
 *
 * @function isTypeOf
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @param {string} type
 * @returns {boolean}
 * @example
 * // returns true
 * isTypeOf({}, "object")
 * isTypeOf([], "object")
 * isTypeOf("foo", "string")
 *
 * @example
 * // returns false
 * isTypeOf("foo", "number")
 */
const isTypeOf = (val, type) => typeof val === type;

/**
 * Checks if the value is an instance of a target constructor
 *
 * @function isInstanceOf
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @param {Class} target
 * @returns {boolean}
 * @example
 * // returns true
 * isInstanceOf({}, Object)
 * isInstanceOf([], Object)
 * isInstanceOf([], Array)
 *
 * @example
 * // returns false
 * isInstanceOf({}, Array)
 * isInstanceOf([], Map)
 */
const isInstanceOf = (val, target) => val instanceof target;

/**
 * Checks if a value is undefined
 *
 * @function isUndefined
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @returns {boolean}
 * @example
 * // returns false
 * const a = {};
 *
 * isUndefined(a.b)
 * isUndefined(undefined)
 *
 * @example
 * // returns false
 * const a = {};
 *
 * isUndefined(1)
 * isUndefined(a)
 */
const isUndefined = (val) => isTypeOf(val, "undefined");

/**
 * Checks if a value is undefined or null
 *
 * @function isNil
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @returns {boolean}
 * @example
 * // returns true
 * isNil(null)
 * isNil(undefined)
 *
 * @example
 * // returns false
 * isNil(0)
 * isNil({})
 */
const isNil = (val) => isUndefined(val) || val === null;

/**
 * Checks if a value is a number
 *
 * @function isNumber
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @returns {boolean}
 * @example
 * // returns true
 * isNumber(1)
 * isNumber(2.34)
 * isNumber(Infinity)
 * isNumber(NaN)
 *
 * @example
 * // returns false
 * isNumber("2")
 * isNumber(null)
 */
const isNumber = (val) => isTypeOf(val, "number");

/**
 * Returns an array of the objects entries
 *
 * `Object.entries` shorthand
 *
 * @function objEntries
 * @memberof Object
 * @since 1.0.0
 * @param {Object} obj
 * @returns {any[]} Array<[key: any, val: any]>]
 * @example
 * // returns [["a", 1], ["b", 2], ["c", 3]]
 * objEntries({a: 1, b: 2, c: 3})
 */
const objEntries = Object.entries;

/**
 * Iterates over each element in an array
 *
 * Wrapper around arr.forEach to have a cleaner API and better minified code
 *
 * @function forEach
 * @memberof For
 * @param {any[]} arr
 * @param {function} fn fn(val: any, index: number, arr: any[])
 * @example
 * // returns a = [0, 2, 6]
 * const a = [1, 2, 3];
 *
 * forEach(a, (val, index)=>a[index] = val * index)
 */
const forEach = (arr, fn) => arr.forEach(fn);

/**
 * Iterates over each entry of an object
 *
 * @function forEachEntry
 * @memberof For
 * @param {object} obj
 * @param {function} fn fn(val: any, key: any, index: number, arr: any[])
 * @example
 * // returns a = {a: 0, b: 2}
 * const a = {a: 1, b: 2};
 *
 * forEachEntry(a, (val, key, index) => a[key] = val * index)
 */
const forEachEntry = (obj, fn) => {
    forEach(objEntries(obj), (entry, index) => {
        fn(entry[1], entry[0], index, obj);
    });
};

/**
 * Checks if a value is an object
 *
 * @function isObject
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @returns {boolean}
 * @example
 * // returns true
 * isObject({})
 * isObject([])
 * isObject(() => 1))
 *
 * @example
 * // returns false
 * isObject(1)
 */
const isObject = (val) => !isNil(val) && (isTypeOf(val, "object") || isTypeOf(val, "function"));

/**
 * Creates a new array with the values of the input iterable
 *
 * `Array.from` shorthand
 *
 * @function arrFrom
 * @memberof Array
 * @since 1.0.0
 * @param {any} arr
 * @returns {any[]}
 * @example
 * // returns a = [1, 2, 3], b = [1, 10, 3]
 * const a = [1, 2, 3];
 * const b = arrFrom(a);
 *
 * b[1] = 10;
 */
const arrFrom = Array.from;

/**
 * The common "if val, then loop, else return first" jQuery pattern
 *
 * @private
 * @param {Object} ctx
 * @param {any} val
 * @param {Function} fn1
 * @param {Function} fn2
 * @returns {any}
 */
const twoWays = function (ctx, val, fn1, fn2) {
    if (val === null) {
        return fn1(ctx[0]);
    } else {
        forEach(ctx, item => {
            fn2(item, val);
        });

        return ctx;
    }
};

/**
 * More advanced version of twoWays
 *
 * @private
 * @param {Object} ctx
 * @param {string|Object} key
 * @param {any} val
 * @param {Function} fn1
 * @param {Function} fn2
 * @returns {any}
 */
const twoWaysMultiple = function (ctx, key, val, fn1, fn2) {
    if (isObject(key)) {
        forEachEntry(key, (entryVal, entryKey) => {
            forEach(ctx, item => {
                fn2(item, entryKey, entryVal);
            });
        });

        return ctx;
    } else if (val === null) {
        return fn1(ctx[0], key);
    } else {
        forEach(ctx, item => {
            fn2(item, key, val);
        });

        return ctx;
    }
};

/**
 * Makes sure a given value is pixels
 *
 * @private
 * @param {any} val
 * @returns {string}
 */
const toPixels = val => isNumber(val) ? val + "px" : val;

/**
 * QQuery class
 *
 * @class
 * @extends Array
 */
const QQuery = class extends Array {
    /**
     * @constructor
     * @param {string|Node|NodeList} query
     * @param {Node} [context=document]
     * @returns {QQuery}
     */
    constructor(query, context = document) {
        let matches;
        super();

        /**
         * Flow:
         *  Is String? -> query match
         *  Is Node? -> use as single match
         *  Is NodeList? -> use as full match
         *  Else -> throw
         */
        if (isInstanceOf(query, Node)) {
            matches = [query];
        } else if (isInstanceOf(query, NodeList)) {
            matches = arrFrom(query);
        } else {
            matches = arrFrom(context.querySelectorAll(query));
        }

        // Pushes items to instance
        forEach(matches, match => {
            this.push(match);
        });
    }
    each(fn) {
        /**
         * For some reason jQuery loops with [index,item] instead of [item,index]
         */
        forEach(this, (item, index) => {
            fn(index, item);
        });

        return this;
    }
    html(val = null) {
        return twoWays(
            this,
            val,
            item => item.innerHTML,
            (item, val) => item.innerHTML = val
        );
    }
    text(val = null) {
        return twoWays(
            this,
            val,
            item => item.textContent,
            (item, val) => item.textContent = val
        );
    }

    val(val = null) {
        return twoWays(
            this,
            val,
            item => item.value,
            (item, val) => item.value = val
        );
    }
    width(val = null) {
        return twoWays(
            this,
            val,
            item => item.clientWidth,
            (item, val) => item.style.width = toPixels(val)
        );
    }
    height(val = null) {
        return twoWays(
            this,
            val,
            item => item.clientHeight,
            (item, val) => item.style.height = toPixels(val)
        );
    }
    attr(key, val = null) {
        return twoWaysMultiple(
            this,
            key,
            val,
            (item, key) => item.getAttribute(key),
            (item, key, val) => item.setAttribute(key, val)
        );
    }
    data(key, val = null) {
        return twoWaysMultiple(
            this,
            key,
            val,
            (item, key) => item.dataset[key],
            (item, key, val) => item.dataset[key] = val
        );
    }
    css(key, val = null) {
        return twoWaysMultiple(
            this,
            key,
            val,
            (item, key) => item.style.getPropertyValue(key),
            (item, key, val) => item.style.setProperty(key, val)
        );
    }
    hasClass(key) {
        return this.every(item => item.classList.contains(key));
    }
    addClass(key) {
        forEach(this, item => {
            item.classList.add(key);
        });

        return this;
    }
    removeClass(key) {
        forEach(this, item => {
            item.classList.remove(key);
        });

        return this;
    }
    toggleClass(key) {
        forEach(this, item => {
            item.classList.toggle(key);
        });

        return this;
    }
    on(event, fn) {
        forEach(this, item => {
            item.addEventListener(event, fn, false);
        });

        return this;
    }
    off(event, fn) {
        forEach(this, item => {
            item.removeEventListener(event, fn, false);
        });

        return this;
    }
    ready(fn) {
        //cannot be registered with other event shorthands because method name is not the event name
        return this.on("DOMContentLoaded", fn);
    }
};

//Bind default events as shorthand methods
"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" ").forEach(eventName => {
    QQuery.prototype[eventName] = function (fn) {
        return this.on(eventName, fn);
    };
});

/**
 * QQuery constructor called as function
 *
 * @param {string|Node|NodeList} query
 * @param {Node} context
 * @returns {QQuery}
 */
const $ = (query, context) => new QQuery(query, context);

module.exports = $;
